# Just Your Tickets - 포트폴리오

> 영화 리뷰 검색 및 공유 플랫폼

## 📋 프로젝트 개요

**Just Your Tickets**는 TMDB API를 기반으로 한 영화 리뷰 커뮤니티 플랫폼입니다. 사용자들이 영화를 검색하고, 리뷰를 작성하며, 다른 사용자들과 영화에 대한 의견을 공유할 수 있는 소셜 플랫폼입니다.

### 🔗 프로젝트 링크

- **배포 사이트**: [https://just-movie-tickets.vercel.app](https://just-movie-tickets.vercel.app)
- **GitHub**: [https://github.com/DaH-115/JUST-MOVIE-TICKETS-dot](https://github.com/DaH-115/JUST-MOVIE-TICKETS-dot)

### 👨‍💻 개발 정보

- **개발 기간**: 2022 - 2024 (지속적 업데이트)
- **개발 형태**: 단독 개발
- **배포 환경**: Vercel 호스팅

---

## 🎯 주요 기능

### 1. 영화 검색 및 추천 시스템

- **실시간 영화 검색**: TMDB API를 활용한 실시간 영화 검색
- **자동완성 기능**: Headless UI Combobox를 활용한 검색 자동완성
- **영화 추천**: 현재 상영작, 트렌딩 영화, 유사 영화 추천
- **상세 정보 제공**: 영화 포스터, 줄거리, 출연진, 예고편 등

### 2. 리뷰 작성 및 관리 시스템

- **티켓 형태 리뷰**: 영화 티켓을 모티브로 한 독창적인 리뷰 UI
- **별점 평가**: 1-10점 별점 시스템
- **실시간 유효성 검증**: React Hook Form + Zod를 활용한 폼 검증
- **리뷰 CRUD**: 작성, 수정, 삭제 기능
- **좋아요 시스템**: 리뷰에 대한 좋아요 기능

### 3. 사용자 인증 및 프로필 관리

- **다중 인증 방식**: 이메일/비밀번호, Google, GitHub 소셜 로그인
- **프로필 관리**: 닉네임, 자기소개, 프로필 이미지 관리
- **중복 검사**: 실시간 닉네임/이메일 중복 확인
- **보안**: Firebase Authentication 기반 안전한 인증

### 4. 커뮤니티 기능

- **댓글 시스템**: 리뷰에 대한 댓글 작성 및 관리
- **좋아요한 리뷰**: 사용자가 좋아요한 리뷰 모아보기
- **내 리뷰 관리**: 작성한 리뷰 목록 및 관리

---

## 🛠 기술 스택

### Frontend

- **Next.js 14**: App Router, Server Components, SSR
- **TypeScript**: 정적 타입 시스템
- **React 18**: 최신 React 기능 활용
- **Tailwind CSS**: 유틸리티 기반 스타일링 + 커스텀 애니메이션
- **React Hook Form**: 효율적인 폼 관리
- **Zod**: 스키마 기반 유효성 검증
- **Redux Toolkit**: 상태 관리
- **Headless UI**: 접근성 높은 UI 컴포넌트
- **Swiper**: 반응형 캐러셀
- **React Icons**: 아이콘 라이브러리
- **React Player**: 동영상 재생 (lazy loading)

### Backend & Database

- **Firebase Authentication**: 소셜 로그인 (Google, GitHub)
- **Firestore**: NoSQL 실시간 데이터베이스
- **AWS S3**: Presigned URL 기반 이미지 저장
- **TMDB API**: 영화 정보 및 트레일러 API

### Development & Deployment

- **Vercel**: 배포 및 호스팅
- **ESLint & Prettier**: 코드 품질 관리
- **Bundle Analyzer**: 번들 크기 최적화 분석
- **Sharp**: 이미지 최적화 (WebP 변환)
- **Web App Manifest**: 홈 화면 추가 지원

---

## 🏗 아키텍처 및 프로젝트 구조

### 디렉토리 구조

```
just-movie-tickets/
├── app/                    # Next.js App Router
│   ├── components/         # 공통 컴포넌트
│   ├── api/               # API 라우트
│   ├── home/              # 홈 페이지
│   ├── search/            # 검색 페이지
│   ├── movie-details/     # 영화 상세 페이지
│   ├── write-review/      # 리뷰 작성 페이지
│   ├── my-page/           # 마이페이지
│   └── ...
├── lib/                   # 유틸리티 함수
│   ├── movies/            # 영화 관련 API 함수
│   └── reviews/           # 리뷰 관련 함수
├── store/                 # 상태 관리
│   ├── redux-toolkit/     # Redux 설정
│   └── context/           # Context API
├── firebase-config/       # Firebase 설정
└── ...
```

### 주요 아키텍처 특징

#### 1. Server-Client 하이브리드 아키텍처

- **Server Components**: 초기 데이터 로딩 최적화
- **Client Components**: 인터랙티브 기능 구현
- **API Routes**: 서버사이드 API 처리

#### 2. 상태 관리 전략

- **Redux Toolkit**: 전역 상태 관리 (사용자 정보)
- **Context API**: 컴포넌트 간 상태 공유 (알림, 영화 상세정보)
- **React Hook Form**: 폼 상태 관리

#### 3. 데이터 페칭 전략

- **Server-side Fetching**: 초기 페이지 로드 시 서버에서 데이터 페칭
- **Client-side Fetching**: 사용자 인터랙션에 따른 동적 데이터 로딩
- **Caching**: Next.js 캐싱 전략 활용

---

## 🔧 핵심 기술 구현

### 1. 영화 검색 시스템

#### 실시간 검색 자동완성

```typescript
// HeaderSearchBar.tsx
const debouncedSearch = useMemo(
  () =>
    debounce(async (query: string) => {
      if (query.trim()) {
        try {
          const res = await fetch(
            `/api/tmdb/search?query=${encodeURIComponent(query)}&page=1`,
          );
          const data = await res.json();
          setResults(data.movies);
        } catch (error) {
          console.error("검색 실패:", error);
        }
      }
    }, 300),
  [],
);
```

#### TMDB API 통합

```typescript
// fetchNowPlayingMovies.ts
export async function fetchNowPlayingMovies(): Promise<MovieList[]> {
  const response = await fetch(
    `https://api.themoviedb.org/3/movie/now_playing?api_key=${TMDB_API_KEY}&language=ko-KR`,
    { next: { revalidate: 86400 } }, // 24시간 캐싱
  );

  const data = await response.json();
  const genreMap = await fetchGenres();

  return data.results.map((movie: MovieList) => ({
    ...movie,
    genres: movie.genre_ids.map((genreId) => genreMap[genreId]).filter(Boolean),
  }));
}
```

### 2. 리뷰 시스템

#### Firestore 실시간 데이터 동기화

```typescript
// useReviewForm.ts
const onSubmit = async (data: ReviewFormValues) => {
  const newData: FirestoreReviewData = {
    user: {
      uid: userState.uid,
      displayName: userState.displayName,
      photoURL: userState.photoURL,
      email: userState.email,
    },
    review: {
      movieId: movieData.id,
      movieTitle: movieData.title,
      rating,
      reviewTitle,
      reviewContent,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
      likeCount: 0,
    },
  };

  await addDoc(collection(db, "movie-reviews"), newData);
};
```

#### 폼 유효성 검증

```typescript
// ReviewForm.tsx
const methods = useForm<ReviewFormValues>({
  defaultValues: {
    reviewTitle: "",
    rating: 5,
    reviewContent: "",
  },
  mode: "onChange",
});

// Zod 스키마 검증
const reviewSchema = z.object({
  reviewTitle: z.string().min(1, "제목을 입력해주세요.").max(50),
  reviewContent: z.string().min(1, "내용을 입력해주세요.").max(500),
  rating: z.number().min(1).max(10),
});
```

### 3. 사용자 인증 시스템

#### 다중 인증 방식 지원

```typescript
// SocialLogin.tsx
const socialLoginHandler = async (provider: SocialProvider) => {
  await setPersistence(
    isAuth,
    rememberMe ? browserLocalPersistence : browserSessionPersistence,
  );

  const authProvider =
    provider === "google" ? new GoogleAuthProvider() : new GithubAuthProvider();

  const { user } = await signInWithPopup(isAuth, authProvider);

  // 신규 사용자인 경우 프로필 생성
  if (!snapshot.exists()) {
    const uniqueNick = await generateUniqueNickname(user.uid);
    await updateProfile(user, { displayName: uniqueNick });
    await setDoc(userRef, {
      provider: provider,
      biography: "Make a ticket for your own movie review.",
      createdAt: serverTimestamp(),
    });
  }
};
```

#### 닉네임 중복 검사

```typescript
// generateUniqueNickname.ts
export default async function generateUniqueNickname(
  uid: string,
): Promise<string> {
  while (true) {
    const candidate = generateNickname();
    const nickRef = doc(db, "usernames", candidate);

    try {
      await runTransaction(db, async (tx) => {
        const snap = await tx.get(nickRef);
        if (snap.exists()) {
          throw new Error("DUPLICATE");
        }
        tx.set(nickRef, { uid, createdAt: serverTimestamp() });
      });
      return candidate;
    } catch (e) {
      continue; // 중복 시 재시도
    }
  }
}
```

### 4. AWS S3 이미지 업로드 시스템

#### Presigned URL 생성

```typescript
// app/api/s3/route.ts
export async function POST(request: NextRequest) {
  const { fileName, fileType } = await request.json();

  const key = `profiles/${Date.now()}-${fileName}`;
  const putCommand = new PutObjectCommand({
    Bucket: process.env.AWS_S3_BUCKET,
    Key: key,
    ContentType: fileType,
  });

  const presignedUrl = await getSignedUrl(s3Client, putCommand, {
    expiresIn: 3600, // 1시간
  });

  return NextResponse.json({ presignedUrl, key });
}
```

#### 이미지 스트리밍

```typescript
// app/api/s3/route.ts
export async function GET(request: NextRequest) {
  const key = searchParams.get("key");

  const getCommand = new GetObjectCommand({
    Bucket: process.env.AWS_S3_BUCKET,
    Key: key,
  });

  const response = await s3Client.send(getCommand);
  const stream = response.Body as ReadableStream;

  return new NextResponse(stream, {
    headers: {
      "Content-Type": response.ContentType || "image/jpeg",
      "Cache-Control": "public, max-age=31536000",
    },
  });
}
```

### 5. 성능 최적화 구현

#### Intersection Observer 활용

```typescript
// VideoPlayer.tsx
useEffect(() => {
  const observer = new IntersectionObserver(
    ([entry]) => {
      setIsVisible(entry.isIntersecting);
      if (entry.isIntersecting && !hasBeenVisible) {
        setHasBeenVisible(true);
      }
    },
    {
      threshold: 0.1,
      rootMargin: "100px",
    },
  );

  if (containerRef.current) {
    observer.observe(containerRef.current);
  }

  return () => {
    if (containerRef.current) {
      observer.unobserve(containerRef.current);
    }
  };
}, [hasBeenVisible]);
```

#### 검색 Debounce 최적화

```typescript
// SearchPage.tsx
const debounceHandler = useMemo(
  () =>
    debounce((query: string) => {
      const cleaned = query.trim().replace(/\s+/g, " ");
      const queryString = cleaned
        ? `?query=${encodeURIComponent(cleaned)}&page=1`
        : "";
      router.replace(`${pathname}${queryString}`);
    }, 300),
  [router, pathname],
);
```

---

## 📊 성능 최적화 성과

### Version 2.0.0 (2025.01.07) 주요 개선사항

| 지표                              | Before | After  | 개선율       |
| --------------------------------- | ------ | ------ | ------------ |
| **번들 사이즈**                   | 234KB  | 88.3KB | **62% 감소** |
| **Lighthouse 성능 점수 (웹)**     | 84     | 98     | **16% 향상** |
| **Lighthouse 성능 점수 (모바일)** | 66     | 94     | **42% 향상** |
| **최대 콘텐츠풀 페인트(LCP)**     | 8.1s   | 3.1s   | **62% 개선** |
| **총 차단 시간(TBT)**             | 280ms  | 10ms   | **96% 감소** |

### 최적화 기법

#### 1. 번들 크기 최적화

- **Dynamic Import**: React Player 등 필요한 시점에 컴포넌트 로딩
- **Tree Shaking**: 사용하지 않는 코드 제거
- **Bundle Analyzer**: 번들 크기 분석 및 최적화

#### 2. 렌더링 성능 최적화

- **Server Components**: 서버사이드 렌더링으로 초기 로딩 최적화
- **React.memo**: 불필요한 리렌더링 방지
- **useMemo/useCallback**: 연산 결과 메모이제이션
- **Intersection Observer**: 뷰포트 기반 lazy loading

#### 3. 이미지 최적화

- **Next.js Image**: 자동 이미지 최적화
- **WebP 포맷**: 최신 이미지 포맷 사용
- **Lazy Loading**: 뷰포트 진입 시 이미지 로딩
- **Blur Placeholder**: 이미지 로딩 중 블러 효과

#### 4. 캐싱 전략

- **ISR (Incremental Static Regeneration)**: 정적 페이지 점진적 재생성
- **API 캐싱**: TMDB API 응답 캐싱 (24시간)
- **Browser Caching**: 브라우저 캐시 활용

#### 5. SEO 및 웹 표준 최적화

- **동적 메타데이터**: 영화별 맞춤 SEO 태그
- **robots.txt**: 검색엔진 크롤링 최적화
- **Web App Manifest**: 홈 화면 추가 지원
- **Open Graph**: 소셜 미디어 공유 최적화

---

## 🎨 UI/UX 디자인

### 디자인 컨셉

- **영화 티켓 모티브**: 리뷰를 영화 티켓 형태로 디자인
- **다크 테마**: 영화관 분위기를 연상시키는 다크 컬러 스킴
- **반응형 디자인**: 모바일부터 데스크톱까지 최적화

### 주요 디자인 요소

#### 1. 컬러 시스템

```javascript
// tailwind.config.js
colors: {
  primary: {
    500: "#8B1E3F", // 버건디
    // ...
  },
  accent: {
    300: "#D4AF37", // 골드
    // ...
  },
}
```

#### 2. 애니메이션

- **Fade In Up**: 컨텐츠 등장 애니메이션
- **Hover Effects**: 인터랙티브 요소 호버 효과
- **Loading States**: 로딩 상태 시각적 피드백

#### 3. 접근성

- **Headless UI**: 스크린 리더 지원
- **키보드 네비게이션**: 키보드만으로 모든 기능 접근 가능
- **ARIA 속성**: 적절한 ARIA 레이블 적용

---

## 🔍 주요 도전과제 및 해결방안

### 1. 성능 최적화

**도전과제**: 초기 로딩 속도 개선 필요
**해결방안**:

- Next.js 14 App Router 도입
- Server Components 활용
- 번들 크기 62% 감소 달성

### 2. 실시간 데이터 동기화

**도전과제**: 리뷰 좋아요, 댓글 등 실시간 업데이트
**해결방안**:

- Firestore 실시간 리스너 활용
- Context API를 통한 상태 관리
- 낙관적 업데이트 구현

### 3. 사용자 경험 개선

**도전과제**: 복잡한 폼 관리 및 유효성 검증
**해결방안**:

- React Hook Form + Zod 조합
- 실시간 유효성 검증
- 사용자 친화적 에러 메시지

### 4. SEO 최적화

**도전과제**: SPA의 SEO 한계
**해결방안**:

- Next.js SSR/SSG 활용
- 동적 메타데이터 생성
- robots.txt, sitemap.xml 구현
- Open Graph 태그 최적화

### 5. AWS S3 이미지 관리

**도전과제**: 안전한 이미지 업로드 및 관리
**해결방안**:

- Presigned URL 기반 보안 업로드
- 이미지 스트리밍 API 구현
- 프로필 이미지 최적화

---

## 🏆 프로젝트 성과

### 기술적 성과

- **성능 최적화**: Lighthouse 점수 대폭 개선
- **코드 품질**: TypeScript 도입으로 타입 안정성 확보
- **사용자 경험**: 직관적이고 반응성 높은 UI 구현
- **확장성**: 모듈화된 아키텍처로 유지보수성 향상

### 학습 성과

- **Next.js 14**: 최신 React 프레임워크 마스터
- **Firebase**: 실시간 데이터베이스 및 인증 시스템 구축
- **성능 최적화**: 웹 성능 측정 및 개선 경험
- **사용자 중심 설계**: UX/UI 디자인 원칙 적용

---

## 📞 연락처

프로젝트에 대한 문의나 피드백은 언제든 환영합니다!

- **GitHub**: [https://github.com/DaH-115](https://github.com/DaH-115)
- **Email**: [kdh941110@gmail.com](mailto:kdh941110@gmail.com)

---

_이 프로젝트는 지속적으로 개발 및 개선되고 있습니다. 최신 업데이트는 GitHub 저장소에서 확인하실 수 있습니다._
